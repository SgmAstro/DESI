import  os
import  sys
import  glob
import  argparse
import  subprocess

from    pathlib import Path
from    subprocess import check_output


parser  = argparse.ArgumentParser(description='Run Lumfn pipeline')
parser.add_argument('--use_sbatch',   help='Submit via Sbatch', action='store_true')
parser.add_argument('--reset',        help='Reset', action='store_true')
parser.add_argument('--nooverwrite',  help='Do not overwrite outputs if on disk', action='store_true')
parser.add_argument('--dryrun',       help='Dryrun', action='store_true', default=True)
parser.add_argument('--survey',       help='Survey', default='gama')

args        = parser.parse_args()
use_sbatch  = args.use_sbatch
reset       = args.reset
nooverwrite = args.nooverwrite
dryrun      = args.dryrun
survey      = args.survey

if dryrun:
    dryrun  = '--dryrun' 
else:
    dryrun  = ''
    
if nooverwrite:
    nooverwrite = '--nooverwrite'
else:
    nooverwrite = ''
    
# print(use_sbatch)
# print(reset)
# print(nooverwrite)
# print(dryrun)

sys.stdout  = open('pipeline.py.log', 'w')

os.environ['USESBATCH']   = str(int(use_sbatch)) 
os.environ['RESET']	  = str(int(reset))
os.environ['DRYRUN']	  = dryrun
os.environ['NOOVERWRITE'] = nooverwrite

print(f'Assuming $USESBATCH={use_sbatch}')
print(f'Assuming $RESET={reset}')
print(f'Assuming $DRYRUN={dryrun}')
print(f'Assuming $NOOVERWRITE={nooverwrite}')

if reset:
    print('\n\n>>>>>  TRASHING GOLD_DIR AND RANDOMS  <<<<<\n\n')

    for root in [os.environ['GOLD_DIR'], os.environ['RANDOMS_DIR']]:
        for ext in ['fits', 'log']:
            cmd = f'rm {root}/*.{ext}'

            # Split on whitespace.
            cmd = cmd.split()

            print(cmd)
            
            # out = check_output(cmd)
            
#  ----  Total of eight jobs, with correct dependency logic  ----                                                                                                                                    
os.environ['RESET'] = '0'

#  ---------------------------------------------
home = os.environ['HOME']

os.chdir(f'{home}')

cmds = []

cmds.append('rm -rf ~/tmp; mkdir -p ~/tmp')
cmds.append('cd ~/tmp/')
cmds.append('git clone https://github.com/SgmAstro/DESI.git')
cmds.append('cd ~/tmp/DESI/')
cmds.append('git checkout main')
# echo 'git branch assumed:  '$(git rev-parse --abbrev-ref HEAD)

for cmd in cmds:
    print(cmd)
    
    # out = check_output(cmd)

code_root = os.environ['CODE_ROOT'] = '~/tmp/DESI/'
os.environ['PATH'] = f'{home}/.conda/envs/lumfn/bin/:{code_root}/bin/:' + os.environ['PATH']
os.environ['PYTHONPATH'] = f'{code_root}/:' + os.environ['PYTHONPATH']

Path(os.environ['GOLD_DIR'] + '/logs/').mkdir(parents=True, exist_ok=True)
Path(os.environ['RANDOMS_DIR'] + '/logs/').mkdir(parents=True, exist_ok=True)

#  ---------------------------------------------
# Generate all steps up to reference LF. 
cmd = 'serialorparallel -p $USESBATCH -e DRYRUN=$DRYRUN,RESET=$RESET,NOOVERWRITE=$NOOVERWRITE -s gold_pipeline -c $CODE_ROOT'

print(cmd)

# gold_jobid = int(check_output(cmd))

print('\n>>>>> GOLD JOB ID <<<<<')
print(gold_jobid)

#
# https://slurm.schedmd.com/sbatch.html
#

sys.stdout.close()

'''
# No dependency.  Generate all steps up to random fill factor and bound_dist. 
RAND_G9_JOBID=$(serialorparallel  -p $USESBATCH -e FIELD=G9,DRYRUN=$DRYRUN,RESET=$RESET,NOOVERWRITE=$NOOVERWRITE  -s rand_pipeline -c $CODE_ROOT)
RAND_G12_JOBID=$(serialorparallel -p $USESBATCH -e FIELD=G12,DRYRUN=$DRYRUN,RESET=$RESET,NOOVERWRITE=$NOOVERWRITE -s rand_pipeline -c $CODE_ROOT)
RAND_G15_JOBID=$(serialorparallel -p $USESBATCH -e FIELD=G15,DRYRUN=$DRYRUN,RESET=$RESET,NOOVERWRITE=$NOOVERWRITE -s rand_pipeline -c $CODE_ROOT)

# Dependency on $GOLD_JOBID (gold ddp cat generated by gold_pipeline).
# Generate ddp1 randoms limited to ddp1 z limits - with corresponding fillfactors, bound_dist etc.  
RAND_DDP_G9_JOBID=$(serialorparallel   -p $USESBATCH -e FIELD=G9,DRYRUN=$DRYRUN,RESET=$RESET,NOOVERWRITE=$NOOVERWRITE  -d $GOLD_JOBID -s rand_ddp1_pipeline -c $CODE_ROOT)
RAND_DDP_G12_JOBID=$(serialorparallel  -p $USESBATCH -e FIELD=G12,DRYRUN=$DRYRUN,RESET=$RESET,NOOVERWRITE=$NOOVERWRITE -d $GOLD_JOBID -s rand_ddp1_pipeline -c $CODE_ROOT)
RAND_DDP_G15_JOBID=$(serialorparallel  -p $USESBATCH -e FIELD=G15,DRYRUN=$DRYRUN,RESET=$RESET,NOOVERWRITE=$NOOVERWRITE -d $GOLD_JOBID -s rand_ddp1_pipeline -c $CODE_ROOT)

echo
echo ' >>>>> RANDOM JOB IDS <<<<<'
echo $RAND_G9_JOBID
echo $RAND_G12_JOBID
echo $RAND_G15_JOBID

echo $RAND_DDP_G9_JOBID
echo $RAND_DDP_G12_JOBID
echo $RAND_DDP_G15_JOBID

# Requires ddp cat, & randoms; no reset required.  
RAND_D8_G9_JOBID=$(serialorparallel   -p $USESBATCH -e FIELD=G9,DRYRUN=$DRYRUN,NOOVERWRITE=$NOOVERWRITE   -d $GOLD_JOBID,$RAND_G9_JOBID  -s rand_d8_pipeline -c $CODE_ROOT)
RAND_D8_G12_JOBID=$(serialorparallel  -p $USESBATCH -e FIELD=G12,DRYRUN=$DRYRUN,NOOVERWRITE=$NOOVERWRITE  -d $GOLD_JOBID,$RAND_G12_JOBID -s rand_d8_pipeline -c $CODE_ROOT)
RAND_D8_G15_JOBID=$(serialorparallel  -p $USESBATCH -e FIELD=G15,DRYRUN=$DRYRUN,NOOVERWRITE=$NOOVERWRITE  -d $GOLD_JOBID,$RAND_G15_JOBID -s rand_d8_pipeline -c $CODE_ROOT)

RAND_DDP_D8_G9_JOBID=$(serialorparallel   -p $USESBATCH -e FIELD=G9,DRYRUN=$DRYRUN,NOOVERWRITE=$NOOVERWRITE   -d $GOLD_JOBID,$RAND_DDP_G9_JOBID  -s rand_ddp1_d8_pipeline -c $CODE_ROOT)
RAND_DDP_D8_G12_JOBID=$(serialorparallel  -p $USESBATCH -e FIELD=G12,DRYRUN=$DRYRUN,NOOVERWRITE=$NOOVERWRITE  -d $GOLD_JOBID,$RAND_DDP_G12_JOBID -s rand_ddp1_d8_pipeline -c $CODE_ROOT)
RAND_DDP_D8_G15_JOBID=$(serialorparallel  -p $USESBATCH -e FIELD=G15,DRYRUN=$DRYRUN,NOOVERWRITE=$NOOVERWRITE  -d $GOLD_JOBID,$RAND_DDP_G15_JOBID -s rand_ddp1_d8_pipeline -c $CODE_ROOT)

echo
echo ' >>>>> RANDOM D8 JOB IDS <<<<<'
echo $RAND_D8_G9_JOBID
echo $RAND_D8_G12_JOBID
echo $RAND_D8_G15_JOBID

echo $RAND_DDP_D8_G9_JOBID
echo $RAND_DDP_D8_G12_JOBID
echo $RAND_DDP_D8_G15_JOBID

# Requires ddp cat. & random fill factor.                                                                                                                                                            
# Note: runs all fields simultaneously.                                                                                                                                         
GOLD_D8_JOBID=$(serialorparallel -p $USESBATCH -e DRYRUN=$DRYRUN,NOOVERWRITE=$NOOVERWRITE -d $RAND_DDP_D8_G9_JOBID,$RAND_DDP_D8_G12_JOBID,$RAND_DDP_D8_G15_JOBID -s gold_d8_pipeline -c $CODE_ROOT)

echo
echo '>>>>>  GOLD D8 JOB IDS  <<<<<'
echo $GOLD_D8_JOBID
echo
echo '>>>>>  DONE.  <<<<<'
echo
echo
'''
