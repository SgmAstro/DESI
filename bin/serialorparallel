#!/usr/bin/bash     
#
# ----  serialorparallel  ----
# 
#  Testing env:  
#    export eflags='FIELD=G9,DRYRUN=$DRYRUN,RESET=$RESET'
#
#
#  Solves:
#    RAND_G9_JOBID=$(sbatch  --parsable --export=FIELD=G9,DRYRUN=$DRYRUN,RESET=$RESET rand_pipeline)
#
#  Wrap a similar call to run in serial (bash), or parallel (sbatch).
#
#
#  Example usage
#
#  ./serialorparallel -p 1 -e FIELD=G9,DRYRUN='__dryrun' -d 99 -s rand_pipeline

unset parallel
unset export
unset dependency
unset script

# dependency: a comma separated list of jobids. 
# export: a comma separated list of env vars, VAR=VAL.
# script: script to run, e.g. rand_pipeline

echo
echo

while getopts ":p:d:e:s:" flag;
do
    case "${flag}" in
	p) parallel=${OPTARG};;
        d) dependency=${OPTARG};;
        e) export=${OPTARG};;
	s) script=${OPTARG};;
    esac
done

if [ "$parallel" -eq "1" ]; then
   # sbatch --parsable --export="$export" --dependency=afterok:"$dependency" "$script     

   echo "sbatch --parsable --export="$export" --dependency=afterok:"$dependency" "$script
   echo
   echo
   exit;
fi

if [ "$parallel" -eq "0" ]; then
   parts=($(echo "$export" | tr ',' '\n'))
   # echo $parts   

   for part in "${parts[@]}"
   do
       blah=($(echo "$part" | tr '=' '\n'))
       
       var="${blah[0]}"
       val="${blah[1]}"
       
       echo "export $var=$val"
   done

   echo
   echo './'$script
   echo
   echo
   exit;
fi

echo  "ERROR:  serialorparallel"
echo
echo
exit;
